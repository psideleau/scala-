import scala.annotation.tailrec
import scala.collection.immutable.TreeSet
import scala.collection.{SortedSet, mutable}
import scala.collection.mutable.{ArrayBuffer, ListBuffer}
import scala.io.StdIn.{readInt, readLine}

import scala.collection.Searching._
/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
class Library {
  val DefaultPrice = 8
  def someLibraryMethod(): Boolean = true


  def minCandy(x: List[Int]) : Int = {
     minCandy(x.sorted, count=0)
  }

  def maxSubArray(nums: Array[Int]): Int = {
    var currentSum = 0
    var positiveSum = 0
    var inNegative = false
    var maxSum = 0
    var maxValue = Integer.MIN_VALUE

    for (i <- 0 until nums.length) {
      currentSum += nums(i)

      if (nums(i) > maxValue) {
        maxValue = nums(i)
      }

      if (nums(i) >= 0) {
        if (inNegative) {
          inNegative = false
          if (currentSum <= 0) {
            currentSum = nums(i)
          }

          if (currentSum >= maxSum) {
            maxSum = currentSum
            positiveSum = maxSum
          }
          else {
            positiveSum = currentSum
          }
        }
        else {
          positiveSum += nums(i)
          if (positiveSum > maxSum) {
            maxSum = positiveSum
          }
        }
      }
      else  {
        inNegative = true
        if (currentSum < 0) {
          currentSum = 0
        }
      }
    }

    return if (maxSum == 0) maxValue else maxSum
  }

  def rob(nums: Array[Int]): Int = {
    if (nums.size == 0) {
      return 0
    }
    var evenSum = 0
    var oddSum = 0

    var i = 0
    var len = nums.size - 1

    oddSum = nums(0)
    while (i < len - 1) {
      if ((i + 3) > len || nums(i + 2) >= nums(i + 3)) {
        oddSum = oddSum + nums(i + 2)
        i = i + 2
      }
      else {
        oddSum = oddSum + nums(i + 3)
        i = i + 3
      }
    }

    if (nums.size == 1)   {
      return oddSum
    }
    i = 1
    evenSum = nums(1)
    while (i < len - 1) {
      if ((i + 3) > len || nums(i + 2) >= nums(i + 3)) {
        evenSum = evenSum + nums(i + 2)
        i = i + 2
      }
      else {
        evenSum = evenSum + nums(i + 3)
        i = i + 3
      }
    }

    return if (oddSum > evenSum) oddSum else evenSum
  }

  object Solution1 {
    def climbStairsR(n: Int, i: Int , count:Int): Int = {
      if (i == n -1) {
        return 1;
      }
      else if (i >= n) {
        return 0
      }
      else {
        return climbStairsR(n, i + 1, count + 1) + climbStairsR(n, i +2, count + 1)
      }
    }
    def climbStairs(n: Int): Int = {
      if (n == 1) {
        return 1
      }
      else if (n == 2) {
        return 2
      }
      return climbStairsR(n, 0,1) + climbStairsR(n, 1,1)
    }
  }

  object Solution2 {
    def climbStairsR(n: Int, i: Int, cache: Array[Int]): Int = {
      if (i == n -1) {
        return 1;
      }
      else if (i >= n) {
        return 0
      }
      else {
        if (cache(i) == -1) {
          cache(i) = climbStairsR(n, i + 1, cache) + climbStairsR(n, i +2, cache)
        }

        return cache(i)
      }
    }
    def climbStairs(n: Int): Int = {
      if (n == 1) {
        return 1
      }
      else if (n == 2) {
        return 2
      }

      val cache = Array.fill[Int](n)(-1)
      return climbStairsR(n, 0, cache) + climbStairsR(n, 1, cache)
    }

    def climbStairsDynamic(n: Int): Int = {
      if (n == 1) {
        return 1
      }
      else if (n == 2) {
        return 2
      }

      val cache = new Array[Int](n)
      cache(0) = 1
      cache(1) = 2

      var i = 2
      while (i < n) {
        cache(i) = cache(i -2) + cache(i - 1)
        i = i + 1
      }

      return cache(n - 1)
    }
  }
  private def minCandy(x: List[Int], count: Int) : Int = {
    var newCount = 0
    val matrix = Array.ofDim[Int](3, x.size)
    matrix(0) = x.toArray
    matrix(1) = x.toArray
    matrix(2) = x.toArray

    while (!isMatch(matrix(0)) &&
      (!isMatch(matrix(1))) &&
      (!isMatch(matrix(2))))  {
      newCount = newCount + 1

      incrementsValuesBy(1, matrix(0))
      incrementsValuesBy(2, matrix(1))
      incrementsValuesBy(5, matrix(2))
    }

    return newCount
  }

  private def isMatch(values : Array[Int]): Boolean = {
    return values.size > 0 && (values(0) == values(values.size -1))
  }

  private def incrementsValuesBy(x : Int, values : Array[Int]) = {
    val max = values(values.size - 1)
    val min = values(0)
    val diff = (max - min)

    println(values.toList)

    var newMaxPos = values.size - 1
    for( i <- 0 to values.size - 2) {
      val newValue = getNewValue(x, values(i), diff)

      if (newValue > max) {
        if (newMaxPos ==  values.size - 1) {
          newMaxPos = i
        }
      }
      else {
        values(i) = newValue
      }
    }

    if (newMaxPos == values.size - 1) {
      values(newMaxPos) = max
    }
    else {
      for (i <- values.size to values.size - 2) {
        values(i + 1) = values(i)
      }
    }


    println(values.toList)
  }


  private def getNewValue(x: Int, currentValue: Int, diff :Int) : Int = {
    if (diff >= x) {
     return currentValue + x
    }
    else if (x == 5 && diff >= 2) {
     return currentValue + 2
    }
    else {
     return currentValue + 1
    }
  }

  def maxProfitEasy(prices : Array[Int]): Int = {
    var minPrice = prices(0)
    var maxPofit = 0

    for (i <- 1 to prices.size - 1) {
        if (prices(i) < minPrice) {
          minPrice = prices(i)
        }

        if (prices(i) > minPrice) {
          if (prices(i) - minPrice > maxPofit ) {
            maxPofit = prices(i) - minPrice
          }
      }
    }

    return maxPofit
  }

//  @tailrec
//  private def minCandy(x: List[Int], count: Int) : Int = {
//    if (x.toSet.size == 1) {
//      return count
//    }
//
//    var newCount = 0
//
//    while (x.toSet.size != 1) {
//      var newCount = newCount + 1
//      var max = x.last
//      val min = x(0)
//      val diff = (max - min)
//      val sublist = x.slice(0, x.size - 1)
//
//      val add1ToSublist = (sublist.map(_ + 1) ++ List(max)).sorted
//
//      val add2ToSublist = if (diff >= 2) ((sublist.map(_ + 2) ++ List(max)).sorted) else List()
//      val add5ToSublist = if (diff >= 5) ((sublist.map(_ + 5) ++ List(max)).sorted) else List()
//
//      if (add1ToSublist.forall(_ == max) ||
//        (add2ToSublist.nonEmpty && add2ToSublist.forall(_ == max)) ||
//        (add5ToSublist.nonEmpty && add5ToSublist.forall(_ == max))) {
//        return newCount
//      }
//      else {
//        val minCandy1 = minCandy(add1ToSublist, newCount)
//        val minCandy2 = if (add2ToSublist.isEmpty) Integer.MAX_VALUE else minCandy(add2ToSublist, newCount)
//        val minCandy5 = if (add5ToSublist.isEmpty) Integer.MAX_VALUE else minCandy(add5ToSublist, newCount)
//
//        return List(minCandy1, minCandy2, minCandy5).min
//      }
//    }
//  }

  def method1(x : Int) : Int = {
    val c = Contest(importance = 1, luck = 34)
    return x + 5;
  }

  def findMinTowers(towerStrength: Int,
                    cities: List[Int],
                    additionalCitiesPreviousTowerCanHold: Int,
                    sum: Int) : Int = {
    if (cities.isEmpty) {
      return sum
    }

    val (currentKList, nextList) = cities.splitAt(towerStrength)

    val citiesWithTowers = currentKList.view.zipWithIndex.filter(_._1 == 1).map(_._2).toList

    if (citiesWithTowers.isEmpty) {
      if (additionalCitiesPreviousTowerCanHold > 0) {
        if (nextList.isEmpty) {
          return if (additionalCitiesPreviousTowerCanHold >= currentKList.size)  sum else -1
        }
        return findMinTowers(towerStrength, cities.splitAt(additionalCitiesPreviousTowerCanHold)._2, 0, sum)
      }
      else {
        return -1;
      }
    }
    else {
      // handle case where additionalCities is > then last tower found in this list.
      val newSum = if (additionalCitiesPreviousTowerCanHold >= currentKList.size) sum else sum + 1

      val newAdditionalCitiesPreviousTowerCanHold = towerStrength - (currentKList.size - (citiesWithTowers.last + 1)) - 1
      return findMinTowers(towerStrength, nextList, newAdditionalCitiesPreviousTowerCanHold, newSum)
    }

  }


//  def findMinTowersSlow(towerStrength : Int, cities: List[Int]) : Int = {
//    val citiesWithTowers = cities.view.zipWithIndex.filter(_._1 == 1).map(_._2).toList
//    val towersPoweringCities = citiesWithTowers.map(c => findMaxRightCityTowerWillCover(c, towerStrength, cities))
//
//    var city = 0
//    var flipCount = 0;
//
//    def max(s1: (Int, Int), s2: (Int, Int)): (Int, Int) = if (s1._2 > s2._2) s1 else s2
//
//    while (city < cities.size) {
//      val towersThatPowerCityRange = towersPoweringCities.
//        filter(t => t._1 <= city && t._2 >= city)
//
//      if (towersThatPowerCityRange.isEmpty) {
//        return -1;
//      }
//
//      val maxRange = towersThatPowerCityRange.reduceLeft(max)
//
//      city = maxRange._2 + 1
//      flipCount += 1
//    }
//
//    return flipCount
//  }

  def findMinTowers(towerStrength : Int,
                    cities: List[Int],
                    city: Int,
                    towersThatPowerCity :  java.util.TreeSet[Int],
                    maxK: Int,
                    totalCities: Int,
                    flipCount: Int) : Int = {

    if (city >= totalCities) {
      return flipCount
    }
    else if (flipCount > maxK) {
      return -1
    }

    val towerThatPowersCityRange  = towersThatPowerCity.lower(city + towerStrength)

    if (towerThatPowersCityRange < (city - towerStrength)) {
      return -1
    }

    if (towerThatPowersCityRange == 0) {
      if(!(city == 0 && towersThatPowerCity.contains(0))) {
        return -1;
      }
    }

    val maxCitiesTowerCanSpan = towerStrength - 1
    val maxRange = findMaxRightCityTowerWillCover(towerThatPowersCityRange, towerStrength, maxCitiesTowerCanSpan, totalCities)

    return findMinTowers(towerStrength=towerStrength,
      cities=cities, city=(maxRange + 1),
      towersThatPowerCity=towersThatPowerCity,
      maxK=maxK, totalCities = totalCities,
      flipCount =(flipCount + 1))

  }

  def hanoi2 (s: String, d: String, e: String, disks: Int, values: ListBuffer[String])  {
    if (disks > 0) {
      hanoi2(s, e, d, disks -1, values)
      values += ("move " + disks + " from " + s + " to " + d)
      println("move " + disks + " from " + s + " to " + d)
      hanoi2(e, d, s, disks - 1, values)
    }

  }

  def hanoi(disks : Int) : List[String] =  {
    val list = ListBuffer[String]()
    hanoi2("s", "d", "e", disks, list)

    list.toList
  }

  def findMinTowers(towerStrength : Int, cities: List[Int]) : Int = {

    val towersThatPowerCity=  new java.util.TreeSet[Int]()
    cities.zipWithIndex.filter(_._1 == 1).map(_._2).foreach(t => {
        towersThatPowerCity.add(t)
      })

    if (towersThatPowerCity.isEmpty) {
      return -1
    }

    val maxK = if (towerStrength >= cities.length) cities.length else  cities.length / towerStrength
    val totalCities = cities.length

    return findMinTowers(towerStrength, cities, city=0, towersThatPowerCity, maxK, totalCities,flipCount = 0)

  }


  def findMaxRightCityTowerWillCover(towerAtCity : Int, k : Int, maxCitiesTowerCanSpan : Int, numberOfCities: Int) : Int = {
    if (k == 1) {
      return towerAtCity
    }

    val tempRightMost = towerAtCity + maxCitiesTowerCanSpan

    val startTime = System.currentTimeMillis()
    val rightMost = if (tempRightMost >= numberOfCities) numberOfCities - 1 else tempRightMost
    val endTime = System.currentTimeMillis() - startTime

    return rightMost
  }

  def printInOrder(ar: Array[Int]) = {
     println(ar.sorted.map( i => String.valueOf(i)).mkString(" "))
  }

  def findMaximumLuckBalance(maxLoses:Int, values: List[Contest]) : Int = {

    val luckOfImportantContestsDescendingOrder = values.filter(_.importance == 1).map(_.luck).sorted(Ordering[Int].reverse)

    val luckOfNonImportantContests = values.filter(_.importance == 0).map(_.luck).sum

    val (losses, wins) = luckOfImportantContestsDescendingOrder.splitAt(maxLoses)

    return (luckOfNonImportantContests + losses.sum) - wins.sum
  }

  def toAndFro(a: Int, b: Int, t: Int): Int = {

    if (t > Math.abs(b - a)) {
      val diff = Math.abs(b - a)

      val completePointCount = (t / diff)
      val remainder = t % diff

      if (completePointCount % 2 == 0) {
        return if (a < b)  a + remainder else a - remainder
      }
      else {
        return if (a < b) b - remainder else b + remainder
      }

    }

    return if (a < b) a + t else a - t ;
  }


  def candles(n : Int, ar: Array[Int]) : Int = {
    val max = ar.max
    val maxes = ar.filter( k => k == max)
    return maxes.length
  }

  def price(books : List[Int]) : Double = {
    if (books.isEmpty)
      return 0

    val booksPurchasedGroupByBookSeries : Map[Int, List[Int]] = books.groupBy(_.self)
    val distinctBooksPurchased = booksPurchasedGroupByBookSeries.size

    distinctBooksPurchased match {
      case 1 => books.size * DefaultPrice
      case 2 =>
        getTotalPrice(books, getDiscountWhenTwoSeries(books, booksPurchasedGroupByBookSeries))
      case 3 =>
        val minSize = getMinDistinctBookSeries(booksPurchasedGroupByBookSeries)
        val discountByTriple = getTripleDiscount(minSize)

        val booksRemainingAfterDiscounts = removeBooksAlreadyCountedTowardsDiscount(booksPurchasedGroupByBookSeries, minSize)
        val discountByPair = if (booksRemainingAfterDiscounts.size < 2) 0 else getDiscountWhenTwoSeries(books, booksRemainingAfterDiscounts)

        getTotalPrice(books, discountByPair, discountByTriple)
      case 4 =>
        val minSize = booksPurchasedGroupByBookSeries.mapValues(v => v.size).values.min
        val discountByFour =  (4 * minSize * DefaultPrice * .2)

        val books3 = removeBooksAlreadyCountedTowardsDiscount(booksPurchasedGroupByBookSeries, minSize)

        val minTriple = if (books3.size < 3) 0 else books3.mapValues(v => v.size).values.min
        val discountByTriple = getTripleDiscount(minTriple)

        val books2 = removeBooksAlreadyCountedTowardsDiscount(books3, minTriple)

        val minPair =  if (books2.size < 2) 0 else books2.mapValues(v => v.size).values.min
        val discountByPair = (getPairDiscount(minPair))

        getTotalPrice(books, discountByPair, discountByTriple, discountByFour)

      case 5 =>
        books.size * DefaultPrice -  (5 * DefaultPrice  * .25)
      case _ => 0
    }
  }

  private def removeBooksAlreadyCountedTowardsDiscount(booksPurchasedGroupByBookSeries: Map[Int, List[Int]], columnsUsed: Int) = {
    booksPurchasedGroupByBookSeries.mapValues(v => {
      v.takeRight(v.size - columnsUsed)
    }).filterNot { case (k, v) => v.isEmpty }
  }

  private def getDiscountWhenTwoSeries(books: List[Int], booksPurchasedGroupByBookSeries: Map[Int, List[Int]]) = {
    val numOfPairDiscounts = getMinDistinctBookSeries(booksPurchasedGroupByBookSeries)
    getPairDiscount(numOfPairDiscounts)
  }

  private def getMinDistinctBookSeries(booksPurchasedGroupByBookSeries: Map[Int, List[Int]]) = {
    booksPurchasedGroupByBookSeries.mapValues(v => v.size).values.min
  }

  private def getTripleDiscount(numberOfTriplets: Int) = {
    (3 * numberOfTriplets * DefaultPrice * .1)
  }

  private def getTotalPrice(books: List[Int], discounts: Double*) = {
    (books.size * DefaultPrice) - (discounts.sum)
  }

  private def getPairDiscount(numberOfPairs: Int) = {
    2 * numberOfPairs * DefaultPrice * .05
  }


}

object Test {
  def main(args: Array[String]): Unit = {
    val value = readLine()
    val numbers = value.split(" ").map(s => Integer.parseInt(s));

    val length = numbers(0)
    val k = numbers(1)

    val line = readLine()
    val cities = line.split(" ").map(s => Integer.parseInt(s));

//
//    val contests = (1 to length).map(i => {
//      val line = readLine()
//      val numbers = line.split(" ").map(s => Integer.parseInt(s));
//      Contest(luck = numbers(0), importance= numbers(1))
//    })

    val library = new Library()
    println(library.findMinTowers(k, cities.toList))
  }
}
